---
title: "Henry County Mitigation Project 2013: Microbial Community Charactorization"
author: "Ariane L. Peralta, Mario E. Muscarella, Jeffrey W. Matthews"
date: "Last updated on `r format(Sys.time(), '%d %B, %Y')`"
header-includes:
  - \usepackage{array}
  - \usepackage{graphics}
output: 
  html_document:
  fig_caption: true
---

Project Description: 

# Initial Setup
```{r}
rm(list=ls())
setwd("~/GitHub/IL_Wetlands/analyses")
se <- function(x, ...){sd(x, na.rm = TRUE)/sqrt(length(na.omit(x)))}
ci <- function(x, ...){1.96 * sd(x,na.rm = TRUE)}

# Code Dependencies
# source("../bin/DiversityFunctions.R")
source("../bin/MothurTools.R")
require("vegan")
require("reshape")
#require("BiodiversityR")
# require("ecodist")
require("ggplot2")
```

# Microbial Data
```{r}
# Import OTU data
# Import Raw Data
WLdata.in <- read.otu("../data/WL.final.shared")

# Remove Mock Community
WLdata.in2 <- WLdata.in[which(rownames(WLdata.in) != "Mock"), ]

# Remove OTUs with less than two occurences across all sites
WLdata <- WLdata.in2[, which(colSums(WLdata.in2) >= 2)]

# Make Presence Absence Matrix
WLdataPA <- (WLdata > 0) * 1

# Make Relative Abundence Matrices
WLdataREL <- WLdata
for(i in 1:dim(WLdata)[1]){
  WLdataREL[i,] <- WLdata[i,]/sum(WLdata[i,])
}

# Log Transform Relative Abundances
WLdataREL.log <- decostand(WLdataREL, method="log")

# Import Taxonomy File
WL.tax <- read.tax(taxonomy = "../data/WL.final.0.03.taxonomy")
```

# Plant Data
```{r}


```


# Environmental Data
```{r}
# Import Environmental Data

design <- read.csv("../data/WL.design.csv", row.names = 1)
treatments <- design$Treatment
levels(treatments) <- c("BallBurlapped", "Bareroot", "Seedling", "Acorn", 
                        "Seedbank", "Reference")
```

# Simple Hypothesis Testing
```{r}
WL.adonis <- adonis(WLdataREL ~ treatments, method = "bray", perm=1000)
WL.adonis

WL.simper <- simper(WLdataREL, group = treatments)
summary(WL.simper)
```

# Microbial Ordinations

## nMDS Plot
```{r}
df.bac <- WLdataREL	# bacteria
df.env <- design	# ENV
df.mds <- metaMDS(df.bac, k=2, trymax=50, zerodist="add")

# Remove Odd sites
WLdataREL.log2 <- WLdataREL.log[c(df.mds$points[, 1] < 0.25), ]
design2 <- design[c(df.mds$points[, 1] < 0.25), ]
treatments <- design2$Treatment

# Rerun
df.bac <- WLdataREL.log2	# bacteria
df.env <- design2	# ENV
df.mds <- metaMDS(df.bac, k=2, trymax=50, zerodist="add")

points <- cbind(as.data.frame(df.mds$points), treatments)
L.centroids <- melt(points, id="treatments", measure.vars = c("MDS1", "MDS2"))
centroids <- cast(L.centroids, variable ~ treatments, mean)


df <- data.frame(design2[,2],design2[,1], df.mds$points[,1], df.mds$points[,2])
str(df)
names(df) <- c("Treatment", "Plot", "Axis1", "Axis2")
df$Treatment <- factor(df$Treatment, levels=c("BallBurlapped", "Bareroot", 
                       "Seedling", "Acorn", "Seedbank", "Reference"))
myColors <- c("#FFF000", "#CCFF00", "#33CC33", "#339933", "#336633", "#FF9933") #pick new
names(myColors) <- levels(df$Treatment)
colScale <- scale_colour_manual(values = myColors)
p1<-ggplot(df,aes(x=Axis1,y=Axis2,label=TRUE))
p2 <- p1+geom_point(aes(colour=treatments), size=5)
 p3 <-p2 + geom_text(aes(label=row.names(df)), size=4) #added labels
 p3 + colScale
#p2 + colScale

# Identify the outliers
which(df$Axis1 > 0.05)
#[1] 11 42 49 56
```

## Principal Coordinates Ordination
```{r}
# Create Distance Matrix
sampleREL.dist <- vegdist(WLdataREL, method="bray")

# Principal Coordinates Analysis
WL_pcoa <- cmdscale(sampleREL.dist, k=3, eig=TRUE, add=FALSE)
  # Classical (Metric) Multidimensional Scaling; returns PCoA coordinates
  # eig=TRUE returns eigenvalues; k = # of dimensions to calculate

# Remove Odd Sites
WLdataREL.2 <- WLdataREL[c(abs(WL_pcoa$points[, 1]) < 0.3), ]
design2 <- design[c(abs(WL_pcoa$points[, 1]) < 0.3), ]
treatments <- design2$Treatment

# Create Distance Matrix
sampleREL.dist2 <- vegdist(WLdataREL.2, method="bray")

# Principal Coordinates Analysis
WL_pcoa <- cmdscale(sampleREL.dist2, k=2, eig=TRUE, add=FALSE)
# Classical (Metric) Multidimensional Scaling; returns PCoA coordinates
# eig=TRUE returns eigenvalues; k = # of dimensions to calculate

explainvar1 <- round(WL_pcoa$eig[1] / sum(WL_pcoa$eig), 3) * 100
explainvar2 <- round(WL_pcoa$eig[2] / sum(WL_pcoa$eig), 3) * 100
sum.eig <- sum(explainvar1, explainvar2)

# Plot
points <- cbind(as.data.frame(WL_pcoa$points), treatments)
L.centroids <- melt(points, id="treatments", measure.vars = c("V1", "V2"))
centroids <- cast(L.centroids, variable ~ treatments, mean)
centroids.se <- cast(L.centroids, variable ~ treatments, se)
centroids.sd <- cast(L.centroids, variable ~ treatments, sd)

cent.dataframe <- t(data.frame(rbind(centroids[1,-1], centroids[2,-1],
                             centroids.sd[1,-1],centroids.sd[2,-1])))
colnames(cent.dataframe) <- c("V1", "V2", "V1e", "V2e")
cent.treats <- rownames(cent.dataframe)

myColors <- c("#FFF000", "#CCFF00", "#33CC33", "#000000", "#336633", "#FF9933") #pick new
names(myColors) <- levels(cent.treats)
colScale <- scale_colour_manual(values = myColors)

# Define Plot Parameters
par(mar = c(5, 5.5, 1, 1) + 0.1)

plot(cent.dataframe[,1], cent.dataframe[,2], type = 'n', las = 1,
     xlim = c(-0.1, 0.15), ylim = c(-0.1, 0.1),
     xaxt = "n", xlab = "", yaxt = "n", ylab="")
arrows(x0 = cent.dataframe[,1], 
       y1 = cent.dataframe[,2] - cent.dataframe[,4], 
       y0 = cent.dataframe[,2] + cent.dataframe[,4],
       angle = 90,
       length=0.1, lwd = 2, code = 3)
arrows(y0 = cent.dataframe[,2], 
       x1 = cent.dataframe[,1] - cent.dataframe[,3], 
       x0 = cent.dataframe[,1] + cent.dataframe[,3],
       angle = 90,
       length=0.1, lwd = 2, code = 3)
points(cent.dataframe[,1], cent.dataframe[,2], 
       cex = 2.5, col = myColors, pch = 15)
legend("topright", legend = cent.treats, col = myColors, 
       pch = 15, cex = 0.75, bty = 'n', inset = c(0.1, 0.05),
       y.intersp = 1.25)

axis(side = 1, labels = T, las = 1, lwd.ticks = 2)
axis(side = 2, labels = T, las = 1, lwd.ticks = 2)
axis(side=1, lwd.ticks = 2, tck = -0.02, labels=F, cex.axis=1)
axis(side=3, lwd.ticks = 2, tck = -0.02, labels=F, cex.axis=1)
axis(side=1, lwd.ticks = 2, tck = 0.01, labels=F, cex.axis=1)
axis(side=3, lwd.ticks = 2, tck = 0.01, labels=F, cex.axis=1)
axis(side = 2, lwd.ticks = 2, tck = -0.02, labels=F, cex.axis=1)
axis(side = 4, lwd.ticks = 2, tck = -0.02, labels=F, cex.axis=1)
axis(side = 2, lwd.ticks = 2, tck = 0.01, labels=F, cex.axis=1)
axis(side = 4, lwd.ticks = 2, tck = 0.01, labels=F, cex.axis=1)

mtext(paste("PCoA 1 (", explainvar1, "%)", sep = ""), side = 1, line = 3, cex = 1.5)
mtext(paste("PCoA 2 (", explainvar2, "%)", sep = ""), side = 2, line = 3.5, cex = 1.5)
      
box(lwd = 2)
```

## Microbial Phylogenetic Ordination 
```{r}



```

# Plant Ordinations







## Responder Analysis Based on PCoA
```{r}
# pcoaS <- add.spec.scores(WL_pcoa, WLdataREL, method="cor.scores",Rscale=TRUE,
#   scaling=1,multi=1)
  # retrieves correlation coefficient for each taxon's relative
  # abudnace with respect to PCoA coordinates (k = 3)

pcoaS <- wascores(WL_pcoa$points, WLdataREL, expand=T)
# pcoaS <- pcoascores(WL_pcoa$points, WLdataREL, expand=T)
# eigengrad(WL_pcoa$points, WLdataREL)

# cor(WL_pcoa, pcoaS)

# Species Correlations

# ### BEGIN R
# ## NMDS
# library(vegan)
# data(dune)
# m <- metaMDS(dune)
# cor(dune, scores(m, dis="si"))
# ## capscale, copying the previous method, but 4 axes
# m <- capscale(dune ~ 1)
# cor(dune, scores(m, dis="si", choices=1:4))
#     ## capscale, the direct way re-using the previous result
#     scores(m, dis="sp", scaling=-2, const = sqrt(nrow(dune)-1)))
# ### END
```

# Mario's Stopping Point 1/13/16

# # PCoA Axis 1 Responders
# cor_spp_a1 <- cbind(EC_tax[,3],pcoaS$cproj[,1])
#   # creates matrix of taxonomy and correlations (r)
# colnames(cor_spp_a1)[7] <- "Corr"
#   # renames correlation column name
# cor_spp_a1 <- cor_spp_a1[order(cor_spp_a1[,7],decreasing=TRUE),]
#   # sorts based on r
# responders_a1 <- cor_spp_a1[a1 <- abs(cor_spp_a1[,7])>0.7,]
#   # subset based on r > |0.7|
# 
# # PCoA Axis 2 Responders
# cor_spp_a2 <- cbind(EC_tax[,3],pcoaS$cproj[,2])
#   # creates matrix of taxonomy and correlations(r) axis 2
# colnames(cor_spp_a2)[7] <- "Corr"
#   # renames correlation column name
# cor_spp_a2 < -cor_spp_a2[order(cor_spp_a1[,7],decreasing=TRUE),]
#   # sorts based on r
# responders_a2 <- cor_spp_a2[a2 <- abs(cor_spp_a2[,7])>0.7,]
#   # subset based on r > |0.7|


# Other Stuff
```{r}
## PCoA Plots ##################################################################
################################################################################

WL.pcoa <- cmdscale(sampleREL.dist, eig = TRUE, k = 3) 
explainvar1 <- round(WL.pcoa$eig[1] / sum(WL.pcoa$eig), 3) * 100
explainvar2 <- round(WL.pcoa$eig[2] / sum(WL.pcoa$eig), 3) * 100
explainvar3 <- round(WL.pcoa$eig[3] / sum(WL.pcoa$eig), 3) * 100
sum.eig <- sum(explainvar1, explainvar2, explainvar3)

# Define Plot Parameters
par(mar = c(5, 5, 1, 1) + 0.1)

# Define Plot Symbols
WL.pch <- rep(NA, length(design$Treatment))
for (i in 1:length(design$Treatment)){

  }

WL.pch <- rep(17, length(design$Treatment))

# Initiate Plot
plot(WL.pcoa$points[ ,1], WL.pcoa$points[ ,2], 
     # ylim = c(-0.31, 0.25), xlim = c(-0.3, 0.6), 
     xlab = paste("PCoA 1 (", explainvar1, "%)", sep = ""),
     ylab = paste("PCoA 2 (", explainvar2, "%)", sep = ""),
     pch = WL.pch, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, 
     axes = FALSE)

# Add Axes
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1, las = 1)
axis(side = 3, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=-0.02)
axis(side = 4, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=-0.02)
axis(side = 1, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=0.01)
axis(side = 2, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=0.01)
axis(side = 3, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=0.01)
axis(side = 4, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=0.01)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)

# Add Points & Labels
points(WL.pcoa$points[ ,1], WL.pcoa$points[ ,2],
       pch = WL.pch, cex = 1.25, bg = "gray", col = "gray")

ordiellipse(cbind(WL.pcoa$points[ ,1], WL.pcoa$points[ ,2]),
            design$Treatment, kind="se", conf=0.95,
            lwd=2, draw = "polygon", col="gray", border = "black", label=TRUE, 
            cex=1, bty = 'n')

text(WL.pcoa$points[ ,1], WL.pcoa$points[ ,2], design$Plot)


names(which(WL.pcoa$points[, 1] > 0.3))

test <- which(WL.pcoa$points[, 1] > 0.3)

###
# Plot with odd samples removed
###
WLdataREL2 <- WLdataREL[c(WL.pcoa$points[, 1] < 0.3), ]
design2 <- design[-which(WL.pcoa$points[, 1] > 0.3), ]
sampleREL.dist2 <- vegdist(WLdataREL2, method="bray")


WL.pcoa <- cmdscale(sampleREL.dist2, eig = TRUE, k = 3) 
explainvar1 <- round(WL.pcoa$eig[1] / sum(WL.pcoa$eig), 3) * 100
explainvar2 <- round(WL.pcoa$eig[2] / sum(WL.pcoa$eig), 3) * 100
explainvar3 <- round(WL.pcoa$eig[3] / sum(WL.pcoa$eig), 3) * 100
sum.eig <- sum(explainvar1, explainvar2, explainvar3)

# Define Plot Parameters
par(mar = c(5, 5, 1, 1) + 0.1)

# Define Plot Symbols
WL.pch <- rep(NA, length(design$Treatment))
for (i in 1:length(design$Treatment)){
  
}

WL.pch <- rep(17, length(design2$Treatment))

# Initiate Plot
plot(WL.pcoa$points[ ,1], WL.pcoa$points[ ,2], 
     # ylim = c(-0.31, 0.25), xlim = c(-0.3, 0.6), 
     xlab = paste("PCoA 1 (", explainvar1, "%)", sep = ""),
     ylab = paste("PCoA 2 (", explainvar2, "%)", sep = ""),
     pch = WL.pch, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, 
     axes = FALSE)

# Add Axes
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1, las = 1)
axis(side = 3, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=-0.02)
axis(side = 4, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=-0.02)
axis(side = 1, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=0.01)
axis(side = 2, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=0.01)
axis(side = 3, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=0.01)
axis(side = 4, labels = F, lwd.ticks = 2, cex.axis = 1, las = 1, tck=0.01)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)

# Add Points & Labels
points(WL.pcoa$points[ ,1], WL.pcoa$points[ ,2],
       pch = WL.pch, cex = 1.25, bg = "gray", col = "gray")

ordiellipse(cbind(WL.pcoa$points[ ,1], WL.pcoa$points[ ,2]),
            design2$Treatment, kind="se", conf=0.95,
            lwd=2, draw = "polygon", col="gray", border = "black", label=TRUE, 
            cex=1, bty = 'n')

text(WL.pcoa$points[ ,1], WL.pcoa$points[ ,2], design2$Plot)


```

# # Stripping PCoA Loadings out of cmdscale Output
# pcoap <- as.data.frame(WL_pcoa$points)
# site <- rep(NA,76)
# site[c(1,3,5,7,9,11,13,15,17,19)] <- "AF1_DNA"
# site[c(21,23,24,25,27,29,31,33,35)] <- "AF2_DNA"
# site[c(37,39,41,43,45,47,49,51,53,55)] <- "EU1_DNA"
# site[c(57,59,61,63,65,67,69,71,73,75)] <- "EU2_DNA"
# site[c(2,4,6,8,10,12,14,16,18,20)] <- "AF1_RNA"
# site[c(22,26,28,30,32,34,36)] <- "AF2_RNA"
# site[c(38,40,42,44,46,48,50,52,54,56)] <- "EU1_RNA"
# site[c(58,60,62,64,66,68,70,72,74,76)] <- "EU2_RNA"
# pcoap <- cbind(pcoap, site)
# 
# #--> AF: Station 1 - DNA
# AF1_DNA_1 <- pcoap[c(1,3,5,7,9,11,13,15,17,19),1]             #PCoA 1 scores
# AF1_DNA_2 <- pcoap[c(1,3,5,7,9,11,13,15,17,19),2]             #PCoA 2 scores
# #--> AF: Station 2 - DNA
# AF2_DNA_1 <- pcoap[c(21,23,24,25,27,29,31,33,35),1]           #PCoA 1 scores
# AF2_DNA_2 <- pcoap[c(21,23,24,25,27,29,31,33,35),2]           #PCoA 2 scores
# #--> EU: Station 5 - DNA
# EU1_DNA_1 <- pcoap[c(37,39,41,43,45,47,49,51,53,55),1]           #PCoA 1 scores
# EU1_DNA_2 <- pcoap[c(37,39,41,43,45,47,49,51,53,55),2]           #PCoA 2 scores
# #--> EU: Station 6 - DNA
# EU2_DNA_1 <- pcoap[c(57,59,61,63,65,67,69,71,73,75),1]        #PCoA 1 scores
# EU2_DNA_2 <- pcoap[c(57,59,61,63,65,67,69,71,73,75),2]        #PCoA 2 scores
# #--> AF: Station 1 - RNA
# AF1_RNA_1 <- pcoap[c(2,4,6,8,10,12,14,16,18,20),1]            #PCoA 1 scores
# AF1_RNA_2 <- pcoap[c(2,4,6,8,10,12,14,16,18,20),2]            #PCoA 2 scores
# #--> AF: Station 2 - RNA
# AF2_RNA_1 <- pcoap[c(22,26,28,30,32,34,36),1]                 #PCoA 1 scores
# AF2_RNA_2 <- pcoap[c(22,26,28,30,32,34,36),2]                 #PCoA 2 scores
# #--> EU: Station 5 - RNA
# EU1_RNA_1 <- pcoap[c(38,40,42,44,46,48,50,52,54,56),1]        #PCoA 1 scores
# EU1_RNA_2 <- pcoap[c(38,40,42,44,46,48,50,52,54,56),2]        #PCoA 2 scores
# #--> EU: Station 6 - RNA
# EU2_RNA_1 <- pcoap[c(58,60,62,64,66,68,70,72,74,76),1]        #PCoA 1 scores
# EU2_RNA_2 <- pcoap[c(58,60,62,64,66,68,70,72,74,76),2]        #PCoA 2 scores
# 
# # Plot Parameters
# par(mfrow=c(1,1), mar=c(5,5,1,1))
# x <- c(min(pcoap[,2])+min(pcoap[,2])*0.25,max(pcoap[,2])+max(pcoap[,2])*0.1)
# y <- c(min(pcoap[,1])+min(pcoap[,1])*0.1,max(pcoap[,1])+max(pcoap[,1])*0.1)
# 
# # Initiate Plot
# plot(pcoap[,2], pcoap[,1], xlab="PCoA Axis 2", ylab="PCoA Axis 1",
#   xlim=rev(range(x)),ylim= y, pch=16, cex=2.0, type='n',xaxt="n",yaxt="n",
#   cex.lab=1.5, cex.axis=1.2)
#     # Creates PCoA byplot for PCoA axis 1 and PCoA axis 2; adds axes labels,
#     # Adjusts axes lengths and size
# 
#   axis(side=1,at=c(-0.4,-0.2,0,0.2), las=1)    # adds x-axis ticks
#   axis(side=2,at=c(-0.2,0,0.2,0.4), las=1)     # adds y-axis ticks
#   segments(-1500, -0, 1500, 0, lty="dotted")   # adds horizontal reference line
#   segments(0, -1500, 0, 1500, lty="dotted")    # adds vertical reference line
# 
#   points(AF1_DNA_2,AF1_DNA_1,pch=21,cex=2.0,col="black",bg="brown3",lwd=2)
#   points(AF2_DNA_2,AF2_DNA_1,pch=21,cex=2.0,col="black",bg="brown3",lwd=2)
#   points(EU1_DNA_2,EU1_DNA_1,pch=21,cex=2.0,col="black",bg="green3",lwd=2)
#   points(EU2_DNA_2,EU2_DNA_1,pch=21,cex=2.0,col="black",bg="green3",lwd=2)
#   points(AF1_RNA_2,AF1_RNA_1,pch=22,cex=2.0,col="black",bg="brown3",lwd=2)
#   points(AF2_RNA_2,AF2_RNA_1,pch=22,cex=2.0,col="black",bg="brown3",lwd=2)
#   points(EU1_RNA_2,EU1_RNA_1,pch=22,cex=2.0,col="black",bg="green3",lwd=2)
#   points(EU2_RNA_2,EU2_RNA_1,pch=22,cex=2.0,col="black",bg="green3",lwd=2)
#     # adds PCoA scores for each to existing graph
# 
#   ordiellipse(cbind(pcoap[,2], pcoap[,1]), pcoap$site, kind="sd", conf=0.95,
#     lwd=2, lty=3, draw = "lines", col = "black", label=FALSE)
#   #legend(-0.25, -0.08,"AF-1-DNA", cex=2.0,col="red",pch=16,bty="n")
#   #legend(-0.25, -0.12,"AF-2-DNA", cex=2.0,col="pink",pch=16,bty="n")
#   #legend(-0.25, -0.12,"EU-1-DNA", cex=1.5,col="darkgreen",pch=16,bty="n")
#   #legend(-0.25, -0.12,"EU-2-DNA", cex=1,col="chartreuse4",pch=16,bty="n")
#   #legend(-0.25, -0.12,"AF-1-RNA", cex=1,col="red",pch=16,bty="n")
#   #legend(-0.25, -0.12,"AF-1-RNA", cex=1,col="pink",pch=16,bty="n")
#   #legend(-0.25, -0.12,"AF-1-RNA", cex=1,col="red",pch=16,bty="n")
#   #legend(-0.25, -0.12,"AF-1-RNA", cex=1,col="pink",pch=16,bty="n")
#     # adds legends to existing graph
#   box(lwd=2)
# 
# ## Hypothesis Testing ##########################################################
# ################################################################################
# 
# site <- rep(NA,76)
# site[c(1,3,5,7,9,11,13,15,17,19)] <- "AF1_DNA"
# site[c(21,23,24,25,27,29,31,33,35)] <- "AF2_DNA"
# site[c(37,39,41,43,45,47,49,51,53,55)] <- "EU1_DNA"
# site[c(57,59,61,63,65,67,69,71,73,75)] <- "EU2_DNA"
# site[c(2,4,6,8,10,12,14,16,18,20)] <- "AF1_RNA"
# site[c(22,26,28,30,32,34,36)] <- "AF2_RNA"
# site[c(38,40,42,44,46,48,50,52,54,56)] <- "EU1_RNA"
# site[c(58,60,62,64,66,68,70,72,74,76)] <- "EU2_RNA"
# 
# station <- rep(NA, 76)
# station[1:20] <- "AF1"
# station[21:36] <- "AF2"
# station[37:56] <- "EU1"
# station[57:76] <- "EU2"
# 
# molecule <- rep(NA, 76)
# molecule[c(1,3,5,7,9,11,13,15,17,19,21,23,24,25,27,29,31,33,35,
#   37,39,41,43,45,47,49,51,53,55,57,59,61,63,65,67,69,71,73,75)] <- "DNA"
# molecule[c(2,4,6,8,10,12,14,16,18,20,22,26,28,30,32,34,36,
#   38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76)] <- "RNA"
# 
# slope <- rep(NA, 76)
# slope[1:36] <- "AF"
# slope[37:76] <- "EU"
# 
# #conduct an Analysis of Similarities (ANOSIM)
# #if consulting dissimilarity ranks, use values from 50% column
# Anosim <- anosim(sampleREL.dist, grouping = site, permutations = 1000, distance = "bray")
# summary(Anosim)
# 
# #conduct a Similarity Percentages analysis
# #an overall average proportional dissimilarity between treatments is not reported, but it can be obtained by summing the values in the contribution column
# #ratio is the average proportional contribution of the respective OTU divided by its SD
# Simper <- simper(sampleREL.dist, group = site)
# summary(Simper)
# 
# 
# # anosim performs an analysis of simliarities on a distance matrix
# # The default distance measure is bray-curtis, but other measures (Chao, Jaccard, Euclidean) can be used when specified
# # Example specifying distance measure: anosim(lter3REL.dist, grouping=c(rep(1,3), rep(2,3)), distance="euclidean", permutations=1000)
# # The grouping argument used here specifies what group (1 or 2) each sample belongs to (here the first 3 samples belong to group 1)
# anosim(sampleREL.dist, grouping=site, permutations=1000)
# 
# 
# # mrpp performs a multi-response permutation procedure to test for within vs. among group differences
# # The default distance measure is euclidean, but other measures (Chao, Jaccard, Bray-Curtis) can be used when specified
# mrpp(t(sampleREL.dist), grouping=site, distance="bray", permutations=1000)
# 
# # adonis runs a permanova (Created by Marti J. Anderson) this is very similar to ANOVA but for multivariate data. You can make very complex
# # experimental designs with it.
# # The default distance measure is bray-curtis, but other measures (Chao, Jaccard, Euclidean) can be used when specified
# adonis(sampleREL.dist ~ molecule + site , method="bray", permutations=1000)
# 
# 
# *******
# data.bact<- read.csv("~/Documents/Projects_ACTIVE/Wetlands_Illinois/2013_HenryCountyMitigation/WLbact_only.csv", header=TRUE)
# data.env<- read.csv("~/Documents/Projects_ACTIVE/Wetlands_Illinois/2013_HenryCountyMitigation/WL_soil.csv", header=TRUE)
# 
# data(data.bact)
# data(data.env)
# (sim <- with(data.env, simper(data.bact, Treatment)))
# summary(sim, ordered=TRUE)
# 
# data(dune)
# data(dune.env)
# (sim <- with(dune.env, simper(dune, Management)))
# summary(sim)
# 
# simper(comm, group,  ...)
# ## S3 method for class 'simper'
# summary(object, ordered = TRUE,
#      digits = max(3, getOption("digits") - 3), ...)
